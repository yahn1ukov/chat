package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"encoding/json"

	"github.com/yahn1ukov/chat/apps/api/internal/dto"
	"github.com/yahn1ukov/chat/apps/api/internal/gql/gqlmodels"
	"github.com/yahn1ukov/chat/apps/api/internal/gql/graph"
	"github.com/yahn1ukov/chat/apps/api/internal/gql/loaders"
	"github.com/yahn1ukov/chat/apps/api/internal/pubsub"
)

func (r *messageResolver) User(ctx context.Context, obj *gqlmodels.Message) (*gqlmodels.MessageUser, error) {
	return loaders.GetMessageUserByID(ctx, obj.UserID)
}

func (r *mutationResolver) SendMessage(ctx context.Context, input gqlmodels.SendMessageInput) (bool, error) {
	userID, err := r.sessionStore.GetUserID(ctx)
	if err != nil {
		return false, err
	}

	dto := &dto.CreateMessageDto{
		Text: input.Text,
	}

	message, err := r.messageService.Create(ctx, userID, dto)
	if err != nil {
		return false, err
	}

	go func() {
		r.pubsub.Publish(pubsub.MESSAGE_ADDED, message)
	}()

	return true, nil
}

func (r *queryResolver) Messages(ctx context.Context) ([]*gqlmodels.Message, error) {
	messages, err := r.messageService.GetAll(ctx)
	if err != nil {
		return nil, err
	}

	return messages, nil
}

func (r *subscriptionResolver) MessageAdded(ctx context.Context) (<-chan *gqlmodels.Message, error) {
	ch := make(chan *gqlmodels.Message, 1)

	go func() {
		sub := r.pubsub.Subscribe(pubsub.MESSAGE_ADDED)

		defer func() {
			sub.Unsubscribe()
			close(ch)
		}()

		for {
			select {
			case <-ctx.Done():
				return
			case data := <-sub.Data:
				var message gqlmodels.Message
				json.Unmarshal(data, &message)
				ch <- &message
			}
		}
	}()

	return ch, nil
}

func (r *Resolver) Message() graph.MessageResolver { return &messageResolver{r} }

type messageResolver struct{ *Resolver }
