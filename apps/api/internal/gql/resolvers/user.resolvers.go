package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"encoding/json"
	"net/http"

	"github.com/yahn1ukov/chat/apps/api/internal/gql/gqlmodels"
	"github.com/yahn1ukov/chat/apps/api/internal/http/middlewares"
	"github.com/yahn1ukov/chat/apps/api/internal/pubsub"
)

func (r *mutationResolver) Logout(ctx context.Context) (bool, error) {
	session := r.sessionStore.GetSession(ctx)

	w := ctx.Value(middlewares.RESPONSE_WRITER_KEY).(http.ResponseWriter)
	req := ctx.Value(middlewares.REQUEST_KEY).(*http.Request)

	session.Options.MaxAge = -1
	session.Save(req, w)

	return true, nil
}

func (r *queryResolver) User(ctx context.Context) (*gqlmodels.User, error) {
	id, err := r.sessionStore.GetUserID(ctx)
	if err != nil {
		return nil, err
	}

	user, err := r.userService.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}

	return user, nil
}

func (r *queryResolver) Users(ctx context.Context) ([]*gqlmodels.User, error) {
	users, err := r.userService.GetAll(ctx)
	if err != nil {
		return nil, err
	}

	return users, nil
}

func (r *subscriptionResolver) UserAdded(ctx context.Context) (<-chan *gqlmodels.User, error) {
	ch := make(chan *gqlmodels.User, 1)

	go func() {
		sub := r.pubsub.Subscribe(pubsub.USER_ADDED)

		defer func() {
			sub.Unsubscribe()
			close(ch)
		}()

		for {
			select {
			case <-ctx.Done():
				return
			case data := <-sub.Data:
				var user gqlmodels.User
				json.Unmarshal(data, &user)
				ch <- &user
			}
		}
	}()

	return ch, nil
}
